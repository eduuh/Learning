Objects

Objects

- The idea behind object-oriented computing is that it makes thinking about and discussing programming similar to thinking about the real world. So to ask what's an object in a computer program, start by asking, what's an object in the real world? - So is this cookie an object? - Sure. - What about this mug? - Absolutely. These are both objects, they're things. - What about this mug? Are these two mugs the same object? - No, although they're similar mugs, they're not the same mug. These are separate objects, each with its own existence. It's own identity that's independent of all other objects. Every object has characteristics, inherent properties that describe its current state. For example, a mug can be full, empty, or somewhere in between. Filling one mug with coffee does not mean all of the mugs in the world get filled. The current state of this mug being full is independent of this other empty mug because they're separate objects. - But there's more to a mug on whether it's empty or full. What about its size? Wait, or color? - Well, most objects will have multiple attributes. Some of those attributes like color and size will remain constant. Whereas other attributes like whether it's full or empty are likely to change over the mug's lifetime. - I usually use the term properties to describe those things. - Sure. Attributes or properties, characteristics, states, fields, variables, those are all related terms that you'll often hear programmers use interchangeably. Their exact meaning may differ slightly depending on the situation and specific context through language but for this course, I'll stick with using the term attributes. - But I still prefer properties. Okay, so it's easy to think of the mug as an object since it's a single thing. But what about something complex like my cellphone which has hundreds of components and electronic parts? - Well, being an object has nothing to do with complexity. And it's possible for one object to contain other objects. I can talk about your phone as a thing in the real world so I can think of it as a computing object with attributes like color, size, and weight. In addition to that, your cellphone has behaviors. It can ring, and it can send text messages. - But the mug can't ring or text. So those behaviors are specific to my cellphone object. - Right, and I wouldn't try to use your cellphone to hold coffee. Identity, attributes, and behaviors. Those are the three things that describe objects in an object-oriented programming language. Every object in a computer program is self-contained so it has its own identity separate from other objects, its own attributes to describe its current state and its own behaviors, the things it can do. - These examples you've used, mugs, cookies, cellphones, they're all things that we can see and touch. But software often describes things that don't have a tangible representation. So can objects in a program represent more than physical things? - Good point. In programming, the idea of an object extends further to describe non-tangible things too. Like a date, a timer, or a bank account. You can't touch and hold a bank account in real life but it's still a well-defined idea that meets the definition of an object. It has identity, one bank account is separate from another bank account. It has attributes like an account number and a balance. And it has behaviors, you can deposit to a bank account and withdraw from it. One of the challenges of object-oriented design is figuring out if something in your application should be represented as an object. That's easy when your application needs something like a mug, a person, or a document. But what if you're building an event management application? Would an event be an object? Well, just ask yourself, is it a noun? Nouns aren't just physical things, but also people, places, and ideas or concepts. As a simple test, if you were talking about it in a conversation, could you put the word the in front of it? The mug, the person, the document. Sure, but also, the bank account, the time, the event. Those work too, those could be objects. However, you would not say the ringing or the texting. Those are verbs that describe the behaviors of an object, not the object itself. We need to identify those verbs as well because a program without any behaviors isn't very useful. But as the name object-oriented implies, when it comes to structuring an object-oriented program, we tend to focus on the nouns first.

### Classes

Selecting transcript lines in this section will navigate to timestamp in the video

- Objects don't just magically appear in a program. We have to create them, and we do so from classes. A class is the detailed description, the definition, the template of what an object will be. but it isn't the object itself. Once we've written a class and defined it, we can use it to create as many objects based on that class as we want. Different classes let us create different types of objects. - Classes are like our collection of cookie cutters. This particular cutter would be the class to create circular cookies. It defines how the cookie will look. But the cutter itself is not a cookie. And we only need this one cutter to create a tray full of round cookies, each a separate object ready for the oven. - Remember that the class always comes first. You can't make round cookies without the circular cutter. Now, there are three components that make up a class in object-oriented programming. Each class has a name, literally what is it? For example, a round cookie. A class can have attributes to describe that object, such as weight, color and whether or not the cookie has icing. And it can have behaviors, the things that object can do, like decorate or consume. Now you might encounter other, somewhat interchangeable, terms for these words. Instead of name, you might see type, because each class creates objects of a particular type. And as we talked about earlier, you might also see attributes referred to as properties, or more generically as data. And behaviors are also referred to as operations. When we actually write those behaviors as code, they're typically called a method. A method is a block of code or procedure that can be called to perform some action, and it may return a value. - What you just described is the textbook definition of a function. Code that performs some action and returns a value. What's the difference between methods and functions? - Well, methods are basically functions with the key difference that methods are defined as part of a class. So they're included in any object in that class. And, since methods exist as part of an object, they can only access data that is known to that object. These concepts of classes and objects can be a bit confusing at first, so let's look at an example using our round cookie class. You'll often see a diagram that looks something like this to sketch out a class, with the name on top, attributes in the middle, and behaviors on the bottom. And we'll look at these diagrams in more detail later. Although the class says that each round cookie will have a size, a color, and possibly icing, it doesn't specify the actual values for size, color, and icing. It's just providing a definition. But, after defining the class, I can create objects based on it through a process called instantiation. And it's called that because each object I create is an instance of that particular class. I've create two instances here for me and Olivia, but there's really no limit to the number I can create. Now, each of the instances, each object has its own identity, independent from other objects. Its own data. The class says that each round cookie has a color, but the individual objects say that my cookie is red and Olivia's cookie, which doesn't have icing, is brown. - I think my cookie needs to be a little bit more colorful, so I'm going to put some blue icing on it. - And since that decorate method only affects the attributes of that instance, my cookie stays red. So, to create objects, I need the class first. And if I haven't defined the class myself, someone else needs to have already defined it for me. Fortunately, most object-oriented languages come with a collection of predefined classes. So you can start creating objects right away. Basic useful things like strings, dates, and arrays are often included as provided classes, so you don't have to begin each program by defining the same common classes over and over again. These classes are defined and then gathered together into frameworks or libraries. In Java, you have the Java Class Library with about 6,000 classes available to you. And the .NET Framework for C# and VB.net has even more than that. C++ has the C++ Standard Library, and Ruby also calls its default library The Standard Library, as does Python.

### Abstraction

- There are four fundamental ideas in object-oriented programming to keep in mind when creating classes. And they have the wonderful names Abstraction. Polymorphism. Inheritance. And Encapsulation. And one way I like to remember these terms is with the delicious acronym A-P-I-E. A pie! Now, these four words can sound intimidating, but you probably do most of them already in daily thought and conversation, even if you don't use these fancy academic terms to describe them. Let me prove that with the first one: Abstraction. If I say, 'person' you know what I mean. I didn't specify who I was thinking of. I didn't even describe the person. Male or female. Tall or short. You might have imagined someone in particular. That's OK. But I don't have to get that specific because you understand the idea of a person. You've known and encountered enough real people to abstract the idea of what a person means. Abstraction means we focus on the essential qualities of something rather than one specific example. By using abstraction, we automatically discard what's unimportant or irrelevant. Your mental model of a person might have a name, a gender, and a height, but it probably doesn't have flavor or icing. Those are things that make sense if I was describing a cookie, but they're irrelevant to the idea of a person. Abstraction means the idea or concept of a person is completely separate from any specific instance. It's what we do all of the time in conversation. And it's at the heart of object-oriented programming because it's what we're doing when we make a class. I don't create separate classes for each person I need to define in my program. I just focus on the essential qualities of the idea I care about and I write one person class. I'll focus on things like: each person has a name, a height, and a gender. And because I always want to discard what's unimportant, it's never just, what does a person class look like? It's, what should a person class look like for this application? Under these circumstances, at this time. Focusing always on just the essentials. So it might be true that every person has a height, but if my application doesn't care about that piece of information, then I don't need that attribute defined in my class.

### Encapsulation

- The idea of encapsulation is about containing the elements of an object. Not just to keep them together, but to also protect them. - Ow! - We bundle an object's attributes or data along with the methods that operate on that data within the sane unit or the same class. One reason for doing that is to restrict access to some of the object's components. - Like how you're restricting me from taking a cookie? - No, you can have a cookie, but you'll have to use my method to get to it. My cookie jar class has an attribute that represents the number of cookies in the jar. When I create an instance of my cookie jar, I don't want you or any other part of my application to be able to reach in and directly change the number of cookies. - Oh, come on. You can trust me. - It's not only about trust. If I let you directly change things, like the number, you might unknowingly change it to something invalid, like a negative one. That value doesn't make sense for the number of cookies and might cause my program to crash. Another reason to restrict access is that, well, maybe I want to limit the number of cookies you can have. - Whoa. No. I don't like the sound of that. So what do I have to do to get a cookie? - Well, to control access to that attribute, I'll hide it so it's only accessible from inside the cookie jar object itself. Then, I'll add a method called 'request cookie' that can be accessed from other parts of the application. When you use the 'request cookie' method, you'll get a cookie, and the method will modify the number of cookies attribute accordingly. One of the principles of encapsulation is that an object should not make anything about itself available except what is absolutely necessary for other parts of the application to work. This is a concept referred to as 'black boxing'. I'm closing off the inner workings of the cookie jar and only revealing specific inputs and outputs. You don't need to know how the 'request cookie' method is implemented under the hood to use it. - But I'm an engineer. I need to know how everything works. - Do you know how your phone works? - Well, sure. I just punch the number into the keypad and it makes a call. - Do you know how it works internally? - Well, you see- - It doesn't matter. If you get a new cellphone, the inner workings can be completely different. But it has the same buttons to press. So you can still use it. One of the main benefits with object orientation is that it allows us to more safely change the way the object works without changing the rest of the application. Perhaps, when I first wrote my cookie jar class, I represented the total number of cookies as a single value. Then, later on, I decide to use three separate values to keep track of each type of cookie individually. Since I hid those attributes, I don't have to worry about breaking the other 20 parts of my application that have been using the 'request cookie' method to grab cookies. I'll just need to modify the 'request cookie' method and the class to handle the change. - Well, if you're the person writing these classes, why would you want to hide your own code? Why keep secrets from yourself? - It's not about being secretive. It's about reducing dependencies between different parts of the application. The change in one place won't cause a domino effect and require multiple changes elsewhere. - Then how much should you hide? - Well, different languages have different levels of support for hiding properties and methods. But the general rule is to encapsulate as much as possible.

Give feedback
0 notifications total

### Inheritance

When I need to create a new class it may not always be necessary to build it from scratch. If my program has an existing class that's similar to what I need, then I can use inheritance to base my new class on that existing one. Inheritance enables a new class to receive or inherit the attributes and methods of existing classes using the same implementation which is a great form of code reuse. Let's say for example I want to model the characters present in a bakery. I might start by defining a class for customers, which has attributes for the customer's name, phone number, email address, and a customer ID number. Additionally I give that customer class a method to update their contact information, and a method to purchase items. The bakery also has employees so I create an employee class with attributes for the employee's name, phone number, email address, and employee ID number. The employee can update their contact information, get promoted, or retire. Now, looking at these two classes side by side, you might have noticed that they have quite a few similarities. Employee's and customer's both have a name, phone number, email address, and a method to update their contact information. Which are things that are common to all people. So rather then defining those attributes separately in each class, I can create a person class with all of those common attributes and methods. And then base the customer and employee classes on it. The phrase to use here is customer inherits from person. Which means the new customer class automatically gets everything in the person class. All of it's attributes and behavior's without having to write any extra code. From there, I can add any additional attributes, and methods that are unique to customer's and employee's. By convention if I'm drawing a class diagram with inheritance I'll use this style of an arrow to show the relationship between these two classes, and indicate it's direction. The term that's most commonly used for this relationship is that the person class is the super class, and the new customer and employee classes are subclasses of it.

You'll also hear these described as the parent class, and the child class, which is typically used when there's only a single level of inheritance, or the base class and the derived class. Which better captures the concept of inheritance that's multiple levels deep. That said there's no limit to the number of child classes I can create based off of a single parent. If I later realize my shop needs another class for the courier that delivers packages, that's easy to add. I'll just create the courier as a subclass of person, and give it a unique method to deliver packages.

In addition to benefiting from code reuse, the great thing about inheritance is that if I make a change in a super class, it will automatically filter down and effect all of the subclasses. So when I realized I should have been keeping track of each person's email address all along, because it's the twenty first century, I only need to add that attribute to the person class, and then the customer, employee, and courier classes will all get the email attributes too. Changing code in one place is much easier then having to change it in three. Now a few languages like Python, and C++, allow you to inherit from more then one super class. Bringing in attributes and behaviors from multiple other classes. However, multiple inheritance can get confusing so it's much more common to see single inheritance where a subclass only inherits from one parent or superclass. Languages like Java, C#, Swift, and Ruby enforce single inheritance with classes and that's what we'll be using in this course.

### Polymorphism

- Our fourth and final object-oriented concept is polymorphism which is a complicated sounding word that simply means having many forms. And appropriately enough, there are multiple forms of polymorphism. One form, called dynamic or run-time polymorphism, allows us to access methods using the same interface on different types of objects that may implement those methods in different ways.

Think of this basic coffee maker as a class with a method to brew coffee. The input parameters for that brew method are a scoop of ground coffee beans and water. I wait a bit for it to brew and the output is a fresh cup of hot coffee. - I prefer to use a different type of coffee maker. A French press. My French press also has a brew method with the exact same inputs and outputs as Baron's basic coffee maker. I input a scoop of ground coffee and some water.

Then after a little while, I press down the plunger and the output is a fresh cup of hot coffee. - Now, although these two coffee makers have the exact same type of inputs and outputs, the way that they brew is very different. My coffee maker uses a filter whereas Olivia's French press strains the coffee with a metal screen. - And although the outputs we received are the same type of object, a cup of coffee, their attributes may have some different values. When it comes to taste, my French press coffee is better. - Now, when it comes to actually implementing this type of polymorphism in code, there are several ways it could be done. Olivia's fancy FrenchPress could inherit all of the attributes and methods from my BasicCoffeeMaker. But then, it replaces the brew method it inherited from the BasicCoffeeMaker through a process called overriding. That allows the FrenchPress to redefine its own unique version of the brew method. - Or perhaps both of these coffee makers inherit from the same abstract class with an abstract brew method.

- Or they both agree to implement the same interface. Inheritance, abstract classes, and interfaces are all possible implementations of polymorphism that we'll cover later on. The benefit of dynamic polymorphism here is that it enables me to use any form of coffee maker as long as it has a brew method that takes coffee grounds and water as inputs and returns a cup of coffee. - Even a really fancy coffee maker like this one? - Well, I've never seen one of those before, but if it has that brew method, I can use it. The other common form of polymorphism is called static or compile-time polymorphism. And it uses a feature of many object-oriented programming languages called method overloading, not to be confused with method overriding. Overloading allows you to implement multiple methods within a class that have the same name, but a different set of input parameters. If I give the brew method of the French press, coffee and water as input arguments, I'll get back a cup of coffee. But if I change the type of inputs, from coffee and water to tea leaves and water, that's a different set of parameters so the French press will execute a different version of the brew method that gives me back a cup of hot tea. Brew with coffee and water and brew with tea and water are two different methods with two different signatures. And the FrenchPress will automatically execute the appropriate one depending on what you give it. - [Olivia] You can also have variations of the method with different numbers of input parameters. I could implement a version of the brew method that takes three inputs, coffee and tea, and water. - You could do that, but I'm not sure you'd want to drink what you get out. In most cases, those overloaded methods will provide different, but very similar functionality. So those are the different forms of polymorphism. Defining different classes that can be used with the same interface. - Or overloading a method from the same class that can take different sets of parameters.

Give feedback
0 notifications total

### Analysis, design, and programming

- When you see the words object-oriented, there's usually another word right beside it, object oriented programming, object oriented design, or object oriented analysis. These are all connected and refer to the idea that to develop any piece of software, you need to do three things, understand your problem, plan your solution, and finally, build it, or rather, analysis, design, and programming. Although they're listed as two separate steps, analysis and design are usually talked about together because they encompass everything that should happen before you write a single line of code. Analysis answers the question what do you need to do? What's the problem you're trying to solve? And design figures out how you're going to do it. In this course, we'll go through an entire object oriented analysis and design process to produce the deliverables, the conceptual design that you, or maybe a separate team of programmers, can take and use to build a solution. - Conceptual is the key word here. We won't be writing any code. - What about drawing diagrams? - Sure. - Sketches on a whiteboard? - Those are great. - Written descriptions? - Absolutely, but no code. Now, there are lots of formal methodologies with their own unique name and conventions, but the ideas are all fairly similar. For this course, we'll follow a typical five-step approach. Start by gathering requirements to figure out what our application needs to do. Really flesh out the problem you're trying to solve. After that, describe the application. Build a narrative in plain, conversational language for how people will use it. Step three involves identifying the most important objects, which is the starting point for identifying actual classes. Once those objects have been identified, formally describe the interactions between them, understanding each object's responsibilities, the behaviors they need to have, and when they interact with other objects. And finally, create a class diagram, which serves as the main output from the five-step process. The class diagram is a visual representation of the classes in the application, and creating it is where the object oriented principles like inheritance and polymorphism really come into play. We'll be diving into each of these steps in more detail, and we'll cover different techniques that you can use for each one.

### Unified modeling language (UML)

- Throughout this course, we'll be using a few common diagramming techniques for drawing classes and their interactions. Thesee. It's a graphical notation for drawing diagrams to visualize object oriented systems. For example, The class diagram gives a very simple graphical representation of a class. It has three sections; the name of the class, its attributes or fields and its behaviors or methods. It allows me to quickly sketch out an idea that's readable and understandable regardless of which programming language I'll be using. UML includes over a dozen different types of structural and behavioral diagrams. Now you should never be asking the question where can I write some sequence diagrams? Instead, you should simply realize that one would come in handy when thinking about or discussing a situation that isn't clear. For this course, we'll only be using a few of the most common types of diagrams including class diagrams and use case diagrams which portray a users interaction with the program. UML is not the goal here and knowing more UML will not necessarily make you a better object oriented developer. In fact, knowing a little UML may actually be more useful than knowing a lot of UML because knowing a lot of UML can lead to an over emphasis on the diagrams themselves. These diagrams should be a quick, useful communication tool. A support system for your brain, not the other way around. I'm a big fan of doing my diagramming work on paper or a whiteboard at least in the initial stages of a project. With that said as a project matures and grows in size, it can be useful to capture those UML diagrams in an electronic format to facilitate sharing amongst team members. There are a lot of tools to choose from here with commercial and open sourse options across every platform. Their capabilities range from simple drawing tools to help you build diagrams, to more advanced tools that can generate code from UML class diagrams. I'm not going to make any particular recommendations here. The single best source for finding out about available UML tools is actually the Wikipedia page List of Unified Modeling Language tools which will allow you to compare tools to see whether or not they're open source, which platforms they run on and the different languages they can generate code for. If you decide that you want to dive deeper into UML then I highly recommend UML Distilled by Martin Fowler. It's a great book, short book, all the UML that 99.9% of developers on the planet would ever need to know.

Give feedback
0 notifications total

#### Defining requirements

- The first step to any design process is to gather your requirements. Figure out what your application or product needs to do. What's the problem you're trying to solve? Why are you building the application in the first place? At the core what are the application's functional requirements? Literally, what does it need to do? What are the necessary features and capabilities? In addition to those, there may also be non-functional requirements that place constraints on how the application should function. For example, an application that handles banking transactions, or one that stores health care data, will likely have to comply with certain regulations. There could be performance requirements such as response time, or how many users can be supported simultaneously. Support requirements, if there's an issue with the application at two A.M. on a Sunday morning, what needs to happen? And security can be considered as either a non-functional or functional requirement depending on the application. From my own experiences, one industry that loves to write laws of detailed requirements is the aerospace industry. - If you're going to put something into space, you need a solid set of requirements to make sure it works right the first time. - So, as a pair of daring aerospace engineers, let's write some requirements together. - We've been tasked to create a space microwave to go onboard our lunar space ship. So the astronauts can have nice warm meals on their way to the moon. Like many projects, creating a space microwave will involve both software and hardware elements but the process of writing requirements is a general skill that applies to all types of projects. - Normally if you're developing an application for a customer or client, you'll want to get as much information to understand the problem they want to solve. Now that client may have only a vague idea of what they need or they think they know exactly what they need, and try to hand you a finished set of requirements. As the developer, always take the time to understand why the client wants to do something to make sure you can give them what they really need. - Well, that sounds really wise, Olivia, but I'm the master of microwave meals, so I'm pretty sure I know all the bells and whistles our space microwave needs. - Bern, I trust you have amazing ideas, but a common trap many developers fall into is having a dozen semi formed ideas about the cool features their app could have, versus nailing down what it really needs to do. If you're the driving force behind an app, and it's your idea, it's easy to think that you've thought through it all. You already know what you want, and you skip this step. Let's focus together, be specific, and write things down. - Fear not, I'm two steps ahead of you. To write the functional requirements, I use the phrase, the system must, or the application must, to describe what it must do. So, the system must heat food in space packages, allow the user to set a time for the food to be ready, notify the user when their food is ready, via space pager, of course, and the system must set the cooking time based on the food it's given. These requirements can be short and simple statements, or they could be something more complicated, as long as it's specific. - Those look pretty good, except for this fifth one. That the application must inherit food types from the abstract super class. Scratch that from the list. What we're doing here, defining requirements, has nothing to do with object orientation. The requirements shouldn't contain words like inheritance, or abstraction, or even class, or object. Those are details that we'll get to later. So, have you thought about non-functional requirements yet? - Of course, they're on the back. Since these describe required characteristics of the application, rather than features, I phrased the non-functional requirements to describe how the application should be. They describe the ilities, like maintainability, reliability, usability, and availability. - [Female Developer] So our system should be available 24/7? - Astronauts are always hungry. - It should be usable while wearing work gloves. And it should be compatible with Windows, Mac, Linx, hold on a second. That last requirement is a bit excessive. Does a microwave really need to be compatible with all those platforms? - Well, not yet, but including that requirement to make sure it's ready for everything. - And that's a common mistake. You don't need to be exhaustive and have answers for everything up front. On the first pass, only focus on capturing the absolute minimum set of requirements. Not the things are optional, or nice to have, or your dream features. Just the bare necessities, your minimum viable product. If the first pass at requirements isn't perfect, that's okay, you can update the requirements later if needed. The goal at this point is to get something written down and that could be as simple as bullet point son paper.

#### FURPS+ requirements

- [Instructor] One commonly used model for classifying software quality attributes is the acronym FURPS which stands for functionality, usability, reliability, performance and supportability. FURPS serves as a checklist of several key qualities to consider when determining requirements. Functionality refers to the capabilities and features of the app. This is a core of what the customer wants. Usability affects the person who will be using the program. Is it easy on the eyes? Is it intuitive to use? Is the documentation accurate and complete? To define reliability requirements, you'll need to know how much system downtime is acceptable. If the failures are predictable and how the system can be recovered. Performance requirements dictate the application's response time through put. And they put limits on the system resources it can use. In supportability. Make sure the application can be tested, extended, serviced and installed and configured. Now in addition to those five categories there is an extension to the FURPS model called FURPS plus which add four more categories. Design addresses constraints on how the software must be built because the app requires certain things such as a relational database. Implementation. Does it have to be written in a certain language? Are there standards or methodologies that need to be followed? The interface typically refers not to the user interface but to an external system that needs to be interfaced with. And finally, physical requirements. Actual physical constraints related to the hardware the application will be deployed on. Keep in mind that the purpose of FURPS plus is to prompt you to think about certain key requirement areas. But not all of these will be relevant to every project. As you go through the list, it's perfectly acceptable to have not applicable or to be determined for some of these categories. Now, requirements analysis is an entire discipline that goes way beyond what we covered in this course. If you need to dive deeper, there are lots of great books on the subject that provide formal processes that you can follow. Software Requirements by Karl Wiegers and Mastering the Requirements Process by Suzanne and James Robertson are great references. If you need to elicit requirements from a customer, particularly in an area you're not familiar with, these are great books and provide some good structures for doing so.

### Challenge: Jukebox requirements

Selecting transcript lines in this section will navigate to timestamp in the video

- All right folks, it's time for a challenge to practice defining requirements. Our astronauts need some music for their long journey to the moon. So we need your help to design a juke box for our moon shuttle. - Now astronauts don't carry money with them, so this juke box will be free to use. - But we don't want to let just one person pick all the music and drive the others crazy, like our last road trip together. - I can't help it, I love disco. - [Female Scientist]The juke box should let a user select an album from the available music library, and then choose individual songs from that album to be played. And as an extra precaution, if one astronaut adds more than three songs in a row to the play queue, and another astronaut wants to play a song, they'll jump ahead in line. Now, your goal for this challenge is to write a set of requirements to design the juke box. Try to come up with at least three functional and three non-functional requirements. But you can certainly write more for extra practice. If you find yourself struggling with where to start on this challenge, use the attributes of FURPS+ to inspire possible requirements. - Now we've intentionally left the details somewhat vague here, because this challenge is about the process of thinking through a new, often half-formed idea to discover and actually write down requirements. There's no one correct answer to this challenge, so take some time to think it through, and when you're done, be sure to watch our solution video to see how we approached the problem.

### Solution: Jukebox requirements

- To work our way towards a solution for the challenge of defining jukebox requirements, we'll use the FIRBS acronym as a guide. "F" stands for Functionality. So, we'll start with functional requirements, the things the system must do. Some of the core functions of a jukebox, or pretty much any music player, include maintaining a music library of albums and songs, allowing users to browse those albums and songs, and, in our case, allowing users to select individual songs, and preventing them from playing full albums. They will also need to maintain a queue of songs to play. - Let's not forget, the most important functionality. The jukebox needs to actually play music. It'd be a pretty lousy jukebox, otherwise. You know, in addition to letting the user browse by album, I think we should include a button that they can click to sort the songs by artist. - That's a good idea, but it should be phrased differently as a requirement. Saying that the system must have a button that the user can click to sort by artist, is too implementation-focused. A better way to capture that requirement, would be to say, the system must allow the user to sort by artist, because it leaves the implementation open ended. Now, for a few more functional requirements that are more specific to our scenario. Our jukebox will need to identify individual users, and track the number of plays per user, to prevent one astronaut from hogging the controls. Notice that we haven't specified how the system will identify the users. The requirement just states that it must do it. - There are several ways we could accomplish that task. Maybe, we give each user a unique ID to type in before they use the system, or we could use a fingerprint reader, or perhaps a smart camera to identify the user's face. At this point, we're not committed to a specific way of accomplishing the identification requirement. So, we'll save those implementation details for a later stage in the design process. Now, let's move on to the nonfunctional requirements, things the system should be. These are where the remainder of the FIRBS attributes will likely contribute. In regards to its usability, the system should be intuitive to use while the astronauts are floating around in space. Maybe that means it'll have really big buttons or voice commands. We don't know, yet. Thinking about reliability, astronauts could need tunes at anytime. So, we'll want the jukebox to be available for them all day, everyday, 24/7. - Our jukebox shouldn't require so much power to operate. That impacts other critical systems aboard the spacecraft. So, a good performance requirement would be for the system to be low-power. - And, we'll certainly need to define a threshold for what low-power actually means. - And finally, to address supportability. I think the jukebox should have an updatable music library, so that astronauts can have some modern song choices. Now, the informal requirements we came up with here are, by no means, a complete set. They're just starting points. If you create your own list of requirements, it might have a lot in common with ours, or it can be wildly different. There's no one right answer, here. The goal is to get comfortable thinking about and writing down requirements.

Give feedback
0 notifications total

### Use cases

Selecting transcript lines in this section will navigate to timestamp in the video

- After hashing out the feature focused requirements that say what the system or application must do, it's time to shift focus towards the user and how they accomplish a particular goal, and one way to capture that is as a use case. There isn't a single right way to write use cases, and they could be written at several levels of formality. But at the very least, a use case needs three essential things: a title that describes a goal, the person who will interact with the application to achieve that goal, referred to as a primary actor, and the execution flow, or steps needed to accomplish the goal, the success scenario here. The title for a use case should be a short phrase with an active verb that describes a goal. - Well, as an astronaut, my first goal would be to heat up a delicious meal package. - A title for that use case could simply be Heat Meal. - What if I want to set a timer to heat that meal package later so it'll be ready when I return from my space walk? - I'd call that Heat Delayed Meal. We want to keep titles short and simple. Both of those examples could be separate use cases, separate distinct goals for the application. Now, in regards to the actor, the reason that we say actor rather than generic user is because we often need to identify exactly who is having this interaction. It could be a user, but it could also be someone more specific, customer, employee, or administrator. - So the actors are all of the humans that could interact with and use the program. - Not just humans, any external entity that acts on the system is an actor, including other computer systems. Now, the real meat of each use case lies in the scenario, the details for accomplishing the goal. One way to write the scenario is as a single paragraph, like this one for the Heat Meal use case. It starts with the astronaut inserting the meal package, the system identifying the package, heating it up for the correct amount of time, notifying the astronaut that it's ready via space pager, and finally, the astronaut returning to remove the hot meal package. The aim is to write this so it's short and succinct, using everyday, non-technical language so it can be understood by a typical user of the application. Another way to format this scenario is as a numbered list of individual steps. So, step one, the astronaut inserts the meal package. Step two, the system identifies the type of meal, and so on. There's not a hard and fast way to write these. I can use different phrasing or different levels of detail. Really, it's whatever makes sense for the situation. - That example describes a normal successful scenario where everything works as expected, but I know if something can go wrong, it will. So how do you capture that in a use case? - Well, use cases are typically written to describe successful operations. But depending on the situation, you can also add extensions or steps for alternative flows, for what happens when things go wrong, like when the system can't identify the meal package, or it has trouble accessing the space pager system. And if it's more useful, you can add other specific details about the scenario. One common example would be a precondition that must be true to begin the use case. Here, to heat a meal, our precondition would be that an astronaut has identified at least one package to cook. That's the only way this use case makes sense. Now, you can take it all the way to what's called a fully dressed use case by adding even more fields for post-conditions, secondary actors, stakeholders, and so on. These often exist as a PDF or Word template that you can fill in. - That just went from simple to complicated real quick. - And that's something to watch out for. Formality often sounds like a good idea, but requiring that level of detail can kill progress. If you're managing a large, formal project with team members spread across the globe, then maybe you need fully dressed use cases. But for most projects, it's much better to have a set of readable, casual use cases than a collection of super formal, multi-page templates that never get completed. - It sounds like you could easily get bogged down writing use cases. - As a rule of thumb, you shouldn't spend more than a few days working on use cases in any iteration of a project. Get 'em done so you can move forward onto the next phase. You may have to make some assumptions if you don't have all the information at this point, and that's okay. The use cases may evolve or change. If you're interested in diving deeper into the world of use cases, Alistair Cockburn's Writing Effective Use Cases is the book on the subject, with terrific examples, common mistakes to watch out for, and discussions on writing style.

### Identifying the actors

- Before you dive headfirst into writing use cases, it's good to spend a few minutes brainstorming possible actors. You're looking for anything that lives outside of your application, but interacts with it to accomplish some goal. - Sometimes identifying the actors is straightforward. If we were building a simple single player video game, then there could be just one actor, the player. - However, something like the space microwave that we're designing could have multiple people interacting with it to accomplish different goals. Thinking about their different job titles or departments can also prompt ideas for use case scenarios. As we're brainstorming, we'll use stick figures to represent each of the possible human actors for our application. - [Man] Well, the spaceship will have several astronauts on board that need to use the space microwave to eat, the mission commander, the pilot, and the flight engineer, and back on Earth, Mission Control will want to monitor the status of the equipment, and I'm sure the astronauts will have nutritionists keeping an eye on what they eat. - Now, in addition to identifying people, you should also ask does the application need to interact with other computer systems or other organizations? Those external systems are considered actors too. - Since we have a requirement to notify astronauts when their meal is ready via space pager, the microwave will need to interface with some sort of space pager system. But we don't know what that system will be yet, or what the interface to it will even look like. - And that's okay. For now, all we're doing is identifying actors as a starting point, which should be painless and straightforward. We can represent that external pager service, whatever it ends up being, as a box over on the right side. I will draw a line to show that it interfaces with our system. As we get further along in the implementation details, we may learn that this one box should actually be several different external systems that the microwave needs to interface with. And if so, we'll just update our collection of actors and use cases accordingly. Now, looking at our list, most of the human actors we've identified are all based on roles or job titles. But keep in mind that the same person with the same role and job title could actually be different actors at different times. The focus should really be on the goal that the actor wants to accomplish, and how we define those actors can vary depending on the use case. For example, in a use case for heating meals, I would expect all of the different astronauts on the spaceship to use the system in the same way, to prepare a package of food. And the people back on Earth, Mission Control and the nutritionist, are simply monitoring that activity. In this scenario, there isn't a difference between the on-board astronauts. They all have the same goal. So this situation really comes down to somebody preparing a meal, and someone monitoring it. So, it might make sense to phrase the actors for this use case as the cook and the monitor, not a job title or a specific role, but a perfectly acceptable name for the actors who take part in this particular use case. - Hold on a sec. Use cases always have a single primary actor and possibly one or more secondary actors, if required, so who's the primary here? The cook or the monitor? - Well, when writing use cases, the primary actors aren't necessarily the most important actor in the scenario. They're just the one who initiated it, so in this situation the primary actor would be the cook, and the monitors would be the secondary actors.

Give feedback
0 notifications total

### Identifying the scenarios

- When writing use case scenarios describe a goal that an actor can accomplish in a single encounter and stay focused on the user's intention, what they really want to accomplish. - So, something like turning on the microwave. - Well, at first, turn on microwave might sound like a good use case. After all, it has an active verb phrase and it could have multiple steps and conditions. But if we emphasize the user's intent, their goal, their goal isn't to turn on the microwave. The reason they want to turn it on is to do something. So what is that something? - Well, they probably just want to cook a meal. - Bingo! Cook meal, generate reports, change settings, order supplies. These are user focused goals. Each with several steps that can be accomplished in one encounter. Turning on the microwave might be a part of one of these use cases, but it's not a use case by itself. On the other side of the spectrum, a goal on the level of feed entire crew or execute mission might be too broad. Those would involve multiple encounters with whatever application is being used. - But I've seen some pretty broad use cases from developers. - True, some people define these broader and smaller use cases as a way of tying things together. But at least initially, you want to focus on the use cases that capture the user's true goal. Emphasizing the goal of one encounter. Now a simple casual use case can have multiple scenarios. You should focus on the main successful scenario, the sunny day use case when everything goes right, but when necessary you can describe the alternate paths or extensions. - Like, when the microwave can't identify the meal packet that's put in it. - Yep. - Or when the astronaut tries to shove too many meal packets in all at once. - Bingo! - Like when a random cosmic ray strikes the microwave and heats the food packages too fast and they all explode. - Too far. You're not trying to envision all the bizarrely, unlikely, but technically possible events. Just focus on the typical situation that would occur, what you'd want to do with those situations. Now you could write these as paragraphs or numbered steps. The goal is readability and ease of creation over formality. When you're writing, use an active voice. Omit needless words and needless detail. It's very common to see sentences phrased like, "the system is provided" "with the meal package by the astronaut," but you could just as easily say, "astronaut inserts meal package." Active voice, easy to read, short and concise. Another common thing you may see, particularly from programmers, is too much detail or the start of describing the implementation. So, "the system connects to the external pager system" "over HTTPS and uses JSON to format the text message" "to be transmitted, then waits for" "a delegated callback response." The goal here isn't to write pseudo-code. That's way too much. For a use case, "system sends pager message," would be perfectly fine. Another thing that's tempting to describe, but doesn't belong in use cases, is the user interface. You should describe the scenario without using words like screen, click, button, select. None of that. There's no, "User pressed the start button." Focus on the intention, the layout of the user interface will follow the function of the application and what it needs to do. - After you've come up with your first set of use cases, how do you know if you've missed anything? - Well, you can never know for sure, but questions that may prompt a new goal or actor are: Who does system administration? If this is a system that needs to be started and stopped, or backed up on weekends, or have software updates applied, who does that and how do they interact with the application? Who manages users and security? Particularly if you have role based actors. What happens if the system fails? Well, the person who reacts to this may not be a classic user, they're certainly an actor. And is anyone looking at performance metrics or system activity logs? These questions will often prompt a couple of fairly obvious actors for the application, particularly if it's being developed for internal use.

Give feedback
0 notifications total

#### User stories

- User stories are another written format for describing parts of an application, but they're shorter and simpler than a use case. A user story still describes a single small scenario from a user's perspective, focusing on their goal, what they want to do and why rather than focusing on the system. But unlike a use case, which can be several pages, a user story is typically written as just one, perhaps two, sentences and they're very commonly written on index cards because that forces us to keep them short and sweet. Even though they're concise, user stories generally follow a format that looks something like this. As a, type of user or role, I want, here you describe the goal, so that, the reason or the benefit. The final part, the so that, is optional, but it's very useful to provide context on how this application will be used. - Here's one for you. As an astronaut, I want to heat up my food so that I can eat a warm meal. - Great! It focuses on one specific goal of one specific user for a particular reason. The idea is that you can quickly brainstorm a lot of user stories, even unique ones. - How' about, as a nutritionist I want to see what astronauts eat so that I can monitor their diet. - Perfect! Let's make the nutritionist's job easier. Just as when writing use cases, the focus is on intent and should not include descriptions of the user interface. - So, "As an astronaut, I want to press a button" "to delay when my food gets cooked," "so that it will be ready later," would be a bad user story? - Right. Leave the user interface out of it. It would be better to say, "As an astronaut, I want to schedule when" "to heat my food, so it will be ready later." That leaves flexibility for how we implement it. Also, avoid detailing alternate paths or exceptions, or listing any technical information in user stories. These are intended to be quick, readable summaries of a specific goal and why the user wants it. They can be done very early on, often right at the start of a project and they serve as a placeholder for deeper conversations that you need to have. - These user stories sound an awful lot like they're just short use cases. - It can seem like that at first, but use cases and user stories really are very different things. The most obvious difference is the format, but they also serve different purposes. A user story acts as a placeholder for a conversation, a reminder that we need to get deeper into the details of something. A use case on the other hand, can be regarded as a record of a conversation that has already happened detailing the steps of how a particular goal may or may not be achieved. Now certain software development methodologies may favor one of these over the other, but use cases and user stories are not the direct competitors. Nor are they necessarily a replacement for writing functional requirements. These are all different tools in your toolbox. Depending on the development methodology you're using, you're likely to use some combination of requirements, use cases, and user stories, but not necessarily all three. And the order in which you create them can vary. However you do it, describing your system in plain language is incredibly useful to identify why we're building this application and those descriptions serve as input for the next stages of the analysis and design process. If you want to learn more about the concise user story format, check out Mike Cohn's book, User Stories Applied for Agile Software Development. It's a book you're likely to see recommended if you use a process like Scrum or Extreme Programming.

Give feedback
0 notifications total

### Identifying the objects

- After defining requirements and writing some use cases or user stories we start to transition from analysis, understanding the problem we're trying to solve, to design, how we're going to organize our solution. And I think a good context for explaining that is the design of a video game. Olivia and I are game developers and I have a brand new idea for a game. Get this. You're a spaceship and you shoot missiles at asteroids that are trying to crash into you. - That feels oddly familiar. What if instead, you're the asteroid and you smash into the spaceships that are trying to blow you up? - That is genius! That's why I married you. - Good, 'cuz I've already done the analysis and written up the use cases. - Well, with the analysis done, our next step is to create a conceptual model. That may sound complex, but a conceptual model simply identifies the most important objects in the application and the relationship between them. Now, I'm using the word, object, loosely here. We're not worried about software objects quite yet, but more generically, what are the things in the application that we need to be aware of. Not everything we pick here will become a class, but a lot of them will. - [Olivia] To identify objects, we'll go through all of our use cases and user stories and any other written requirements to pick out all of the nouns. - That's one benefit of actually writing out all those descriptions. - I'll start with this use case that describes the player's asteroid dodging a missile from one of the spaceships by simply highlighting and underlying all of the nouns. The system spawns enemy spaceship in play area. Spaceship flies towards player asteroid and fires missile at it. Player steers asteroid in direction to avoid missile path. Missile flies past player asteroid and disappears offscreen. As I'm gathering a list of potential nouns, I fight the urge to analyze or judge the words. I don't worry if there's a better word to use or if, perhaps, we used a different noun to describe it elsewhere. - And if you miss one, don't worry! It happens. Now, we can take a first pass through our list and find if there are any obvious duplicates. - [Olivia] Well in this use case, the word, it, refers to the asteroid. So that's an easy one to remove. - [Programmer] You'll often find yourself combining some of these or even splitting them up. Picking out the nouns is merely a starting point and you'll find that sometimes attributes start to announce themselves. - [Olivia] The word, offscreen, is really part of the concept of area. So, offscreen might be an attribute of an area class depending on how things get organized, but we're not focused on showing that kind of data now. So I'll remove it. Now, to me, the noun, direction, feels questionable here. Direction is where something goes, but should it really be an object? - At this point, if you're in doubt, keep it. We could implement the asteroid's direction as an attribute with simple values to represent its velocity in each axis, and in that case we wouldn't need a separate class for direction. On the other hand, if that direction of travel might need to be translated between different coordinate systems, then encapsulating that behavior in a direction class could be useful. We aren't that far into the design process, so we don't know yet. Let's keep it, because we can always make changes later. One last item to remove. Even though, system, was used as a noun, let's remove it here and we'll explain the reason why a little later on. So, that leaves us with a handful of nouns from this one casual use case. These are just the names of potential objects and by simply drawing a box around each of those objects we have the beginning of a conceptual model.

### Creating class diagrams: Attributes

- All of our previous work, writing requirements and use cases and building a conceptual model, was to figure out our first set of classes, so now it's time to create a proper class diagram to visually represent them. And this is where specific object-oriented principles, like inheritance and polymorphism, can start coming into play. The most common format to use is the UML class diagram. These can get pretty advanced, but for this course, we'll stick with using just the most common aspects. Each class should have a name written in the singular form, not plural, and the standard is to use an uppercase first letter, so things like Asteroid, Missile, Spaceship. Now, you won't know all of the attributes yet, because the focus so far has been on class responsibilities and behaviors, but start by writing down any obvious ones, and you can always add more later. Use whatever naming convention is typical for your programming language. I'm using the common camel case format here, which starts with a lowercase first letter and then uses uppercase for additional words. While it's common to just write the attribute names, you can also suggest a data type using a colon. So colon String for callSign, I want each of the enemy spaceships to have a unique name, colon Boolean for the shieldActive flag, colon Integer, and colon Coordinate. I can also describe a default value, using an equal sign after the data type. Not all attributes need that, just where it's relevant and important. As you're initially creating class diagrams, don't get hung up on knowing the exact data types to use. Should shieldStrength be a 16-bit integer or a 32-bit integer, or even 64? We'll get to those details later, during implementation. But for now, the diagram makes it clear that we need some sort of integer. Along the same lines, coordinates for the position attribute could be implemented several different ways. It could be split into two separate attributes for the x-coordinate and the y-coordinate. Or it could use a more complex data type, like a tuple or an array to store a pair of values. Or I might create my own custom class for coordinates. Again, details that we'll need to work out later.

#### Creating class diagrams: Behaviors

- When it comes to adding behaviors to our class diagram, we should have a good idea of what to write here from creating our conceptional object model and CRC cards. I'll use the same camel case format as the attribute names. But since these represent operations, they're usually named as short verb phrases; getShieldStrength, reduceShield, and simply move. It's common practice to name methods that modify and retrieve attributes as get instant operations rather than things like change or retrieve. And some languages will even automatically generate getter and setter methods for you. Since these will eventually turn into code, we'll add parenthesis containing any parameters. For example, the reduceShield method takes an integer as it's input parameter. On the other side, I could also add a return type by putting a colon after the parenthesis followed by the return type I'm expecting back from the operation. - Now these classes may have a lot of functionality internally, but the focus here is on public visibility. What are the operations that other objects need to know about? And this is in line with the principle of encapsulation. To hide as much of the implementation as possible, and only share what's absolutely necessary to expose to other classes. You'll commonly see plus and minus signs before the attributes and methods in UML class diagrams. Which is referred to as controlling visibility. Minus indicates that a member should be private to the class, meaning it's not directly accessible by other objects, and plus means the member should be public. So, we've made the shieldStrength attribute private here but we'll allow other objects to retrieve it using the public getShieldStrength method which returns in integer value. We want the setPosition method to only be used internally by other methods in this object, such as the move method, so we decided to keep it private. The rule here is to leave as many attributes and methods private as possible, and only make something public if you know another object will need to use it. - You know, these class diagram aren't that hard to create. And it seems like we could've saved a lot of time if we just jumped straight to trying out classes. - We could do that but what often happens when people jump straight to object creation, is they focus on the data. They decide they need a space ship object but the way they start to build the spaceship is to have a call sign, size, shape, color, mass, thrust, position, velocity, shield strength, the obvious attributes. - So what are the behaviors? - That's the problem. It might be true that these objects need those attributes, but it's the wrong initial focus. If you find yourself defining classes that are strangely devoid of any behavior, you might want to revisit those responsibilities. Do a little work with the requirements, written descriptions, and the conceptional model, or CRC cards. Your focus should really be on what object do rather than just viewing them as data structures.

#### Converting class diagrams into code

- Olivia, so far we've looked at all the ideas and concepts of object orientation, but at the end of the day all of this design work we're doing will need to be converted into a programming language. So, can we start looking at code yet? - Yes, Barron. It's code time. - Finally! There are lots of different object oriented languages to choose from and each has their own unique way of doing things. So we want to show you that the high level concepts we've been discussing here work across languages, even though the implementation details, like syntax, will be different. To demonstrate that, I've simplified the spaceship class to only have two attributes, a public call sign, which is a string and a private integer to represent its shield strength. And it has two methods that are both public, fire missile, which returns a string and reduce shield, which returns nothing or at least that's what this class diagram says, but it does take an integer as input. So, to turn this into Java code, we would use the words, public class spaceship, to actually create the class with opening and closing curly braces to wrap its contents. The first section containing instance variables is labeled with two forward slashes that represent the comment and these are variables that belong to an instance of this class. Meaning that, every spaceship object we instantiate from this class will have its own copy of these variables. We've used the Java keywords, public and private, to set the visibility levels of those variables to match the UML diagram. - If you're unfamiliar with Java or other curly braced formatted languages, don't worry about the syntax here. We're showing you this to get a sense of the kind of key words languages could use, how variables are named, and methods and so on. And to give you a sense of how similar many of these languages can be. In fact, if we take that spaceship class at the same level of complexity and convert it into C#, it would look identical to Java. Java and C# are very similar and they implement a lot of these ideas the same way. We have the two instance variables and two methods. One called fire missile, that returns a string and one called reduce shield that takes an integer called, amount, and returns void, meaning that it returns nothing. Swift is another curly braced formatted language, but it has some differences from Java and C#. The syntax for declaring instance variables uses the keyword, var, and it specifies a type at the end of the statement. We've also followed the naming convention of adding an underscore to the front of the shield strength variable to indicate that it's private. The symbols and syntax differ, but it has the same basic elements as its C# counterpart. - If we make the jump to my favorite language, Python, we drop the curly braces because Python uses line spacing to indicate separate sections of code. Another noticeable difference with Python is that our two instance variables are declared inside of a special method called, init, which gets called when we create an instance of this class. Variables declared outside of that method will have a different scope, which we'll get to a bit later. Finally, Python doesn't really differentiate between public and private variables. It puts trust in the hands of the programmer not to do anything foolish. So we've added an underscore to the shield strength variable name to indicate that it should be treated as if it were private. And for one last example, Ruby, which also leaves out the curly braces and has a simple syntax because, like Python, Ruby is a dynamic language. Meaning that it does not require as much information regarding variable types or return types. The at symbol in front of the variable names, call sign and shield strength, indicate that they're instance variables and Ruby's naming convention for variables uses an underscore between words rather than an uppercase letter. Now, there are many more languages than we covered here and some have substantially different implementations of these ideas, such as JavaScript or Lua or Go. Those don't even have official classes, but the generic object oriented concepts that we're exploring here still apply.

#### Instantiating classes

- When we write the class for a spaceship in our video game, we're creating the blueprint to build the spaceship. Now, the blueprint itself isn't a usable object, but from that class, we can instantiate or create one or more instances of that type of spaceship object. And to do that, many object-oriented languages use the keyword new. In Java, we'd say Spaceship then the variable name myShip equals new Spaceship with open and close parenthesis. And that instantiation line would be identical in C#. C++ looks very similar to Java and C# except it's using the asterisk to indicate a pointer. Don't get caught up in syntax here, these are just some examples to show how languages differ. Ruby is unique in that it puts the keyword new after the class name. But not all languages use new. In Python, it's simply myShip equals Spaceship, and Swift uses the keyword let to assign the newly instantiated Spaceship to the variable named myShip. When we use one of these instantiation statements, shown here in a typical Java or C# format, in the background, the computer will allocate a section of memory to hold the new object, including space for each of the variables in it. It initializes those variables to some value, returns a reference to that object in memory, and that gets assigned to a variable named myShip so we can begin using it. Now, you should always consider what the internal state of an object will be immediately after you instantiate it. Our simplified Spaceship class defines two attributes, callSign as a string and shieldStrength as an integer, and when the object is created, they'll be given some default values. In Java, the default value for a string is Null and the default value for an integer is zero. If we don't take those default values into consideration and our program tries to use them, that could lead to some undesired behaviors, and that's dangerous. Now, we could go and set those values immediately after we create the object but it would be better if we created the object in a meaningful state to begin with. To do that, we'll use what's called the constructor. It's a special method that gets called when the object is instantiated to help configure it. We can use the constructor method to make sure that any variables belonging to the object are set to the values we want when the object is created. In Java or C#, you create a constructor by simply defining a new method in the class with the same name as the class itself. So, the constructor for the Spaceship class will be a method named Spaceship. However, unlike other methods, the constructor does not have a return type because you never call it yourself. It gets called when you use the keyword new to instantiate a new object. Inside the constructor, we set the initial state that we want these instance variables to have. We'll set the callSign to be The nameless ship and give it a shieldStrength of 100. Now, when we use that same line of code to instantiate the object, it will be initialized with those specific values that we want instead of the default values of Null and zero. In a UML class diagram, this type of basic constructor method that doesn't take any arguments is represented as a method with the same name as the class.

### Class with multiple constructors

- We've defined a constructor to instantiate our spaceship object, and it sets the callsign attribute to a value of the nameless ship. But, what if I don't want all of the ships we instantiate to have a callsign of the nameless ship? That'd get confusing. - Well, most languages will let us create multiple constructor methods through a process called overloading, which allows a class to have more than one method with the same name, but different sets of input parameters. To do that in Java, we'll create a second method in this spaceship class, also called spaceship, but this one takes a parameter. Just a string, which I've called name and that gets assigned to the callsign variable. Now when we instantiate a spaceship object, we have two ways of doing it. We can use the word new with no parameters, like before, which will call the first constructor method to give us the nameless ship, or, we can use the word new, along with a string parameter. When we include the string parameter, it's going to call the overloaded constructor, which sets those attributes to different values. Overloading multiple constructors gives us flexibility to pass in information when actually creating the object. And in UML, that would be represented with something like this. We have two methods, with the same name as the class, one with a parameter and one without. This is a very simple example, but constructors become crucial when you have more complex objects. It's often very important to make sure objects aren't instantiated in an invalid state, particularly when one object needs to contain other objects and often has to create them as part of that instantiation process. - Now constructors give birth to an object, but on the other end of an object's lifetime, is the idea of a destructor. The destructor is a method that gets called when an object is no longer needed and is being disposed of. Languages that use garbage collection use something called a finalizer, rather than a destructor, but the concept is the same. It's a place to put some code that will automatically be called when the object is destroyed. Destructors are typically used if you have an object that's holding a resource. Say it has a document open on the file system or it's connected to a database, and you need to make sure that the object releases its connection to that resource, before it's destroyed.

#### Static attributes and methods

- When we instantiate a bunch of enemy spaceships for our game, we'll want each of those spaceship objects to keep track of its own remaining shield strength independent of the others. That way, if the player's asteroid smashes into one of the ships, it'll reduce its shield strength, while the other ships remain unaffected. We've accomplished that by storing the ship's shield strength as an instance variable, which means each instance of the spaceship class will have its own separate copy. - What do you think about adding a different difficulty setting to our game? We could scale the toughness of all the ships, making their shields easier or harder to destroy. - Sounds good to me. - But unlike shield strength, the spaceships' toughness value should not vary from ship to ship. If the player decides to increase or decrease the game's difficulty, then all of the ships should increase or decrease their toughness the same amount. - Well, if we create toughness as another instance variable, that would require us to individually update each of the spaceships any time there's a change to keep them all synchronized. We could do it that way, but it's not very efficient, especially as the number of spaceships grows. The smarter route would be to create a static variable, which is a variable that's shared across all objects in the same class. This is also referred to as a class level or shared variable. Those terms mean the same thing. Now, with a static variable, there's only one copy of toughness to update. If one spaceship changes that shared toughness value, it changes for all of them. - Isn't that just a global variable? I've always been told to avoid using global variables. - Sort of, it's global amongst the spaceships but not the rest of the program. We didn't just toss it into some global dumping ground for variables. That's not good programming. But we do want all of the spaceships to have the same toughness, so it's shared within the class, but still encapsulated. - Static seems like a bad name for it, because to me, static means unchanging. - Well, it is unchanging in the number of copies of a static variable never changes. There will only be one. As for the number of instance level variables, that can vary from run to run, depending on how many objects the program creates that time around. As a basic example of how this is handled in code, if we're using a language like C Sharp or Java, we would include the word static in the line that declares the variable. Of course, other languages handle it differently. Python doesn't use the static keyword. Instead, variables that are declared within a class, but outside of a method, are considered static or class variables, and in Ruby, class variables are declared using two @ symbols instead of just one @ symbol for instance variables. When it comes to accessing instance level variables, we use the name of the object to get to them. So to access the call sign of the spaceship object named Ship One, we would use ship1.callSign. But if we want to access a static variable, we need to use the class name, not a particular instance name. So spaceship.toughness. Even if you haven't instantiated any objects of this class yet, you can still use any variables defined as static. So we could set the toughness for the entire spaceship class before instantiating any spaceship objects. - Now, in addition to static variables, we can also create static methods that exist at the class level. Like when creating static variables, in Java or C Sharp we simply add the keyword static to a method declaration to indicate that it's a static method, and there's only one of it. Since static methods exist at the class level, they can only access static variables. They can't touch instance variables, and static methods are always called using the class name, not the name of an instance. In UML diagrams, static members of a class are typically denoted with an underline, so here toughness is a static attribute, and increase difficulty is a static method or behavior.

### Challenge: Jukebox class diagrams

- It's challenge time again. This challenge builds on the previous one, which involved creating the conceptual model of a spaceship jukebox for astronauts to listen to music. For this challenge, I want you to create a UML class diagram, based on that conceptual model of a jukebox. If you've been following along and creating your own solutions for the challenges thus far, then I encourage you to continue using your own conceptual model or CRC cards for this. Otherwise, feel free to use the conceptual model we created in the previous challenge and solution videos, which is shown here. It contains six objects, the user, library, album, song, cue, and admin. The corresponding responsibilities are listed under the object's name and the interesting relationships and collaborations between objects, are represented with lines. To create the UML class diagrams, you'll need to think about the attributes and methods each class will need to accomplish its responsibilities. You'll likely need to make some assumptions along the way, and that's great practice. We've intentionally kept these challenges open-ended. There are lots of possible solutions here, so take some time to think it through, and when you're done, watch our solution video to see how we approached this problem.

#### Identifying inheritance situations

- Inheritance is one of the four key concepts of object orientation. It allows one or more classes to inherit the attributes and methods of another class, referred to as the parent or superclass. The inheriting subclasses or child classes automatically have all of the attributes and methods of their parent class. And they can have their own unique attributes and methods in addition to those. The advantages of code reuse and code maintenance make inheritance a really powerful tool if you can recognize when to use it. - Hey, Baron. I've been designing different types of space ships for a video game. I've got a star fighter that can shoot missiles at a player. - Mm-hmm. - And a cargo shuttle that carries, well, cargo. If the player asteroid's smashes into the cargo shuttle, it acts like a pinata that drops power ups into space. - Ha, cool. Well I sense there's some sort of relationship going on here, and the best way to identify if it's inheritance, is with two simple words, is a. Inheritance describes an is a relationship between objects. Now that's not some technical term. It's just plain language, how you would talk about things in the real world. So I could say that a star fighter is a spaceship, or a cargo shuttle is a spaceship. Both of those make sense. But saying that a cargo shuttle is a star fighter does not. Those two things have a different relationship with each other, not inheritance. - I find that using the phrase is a kind of, or is a type of, is sometimes easier to use than is a. So a star fighter is a kind of spaceship, or a cargo shuttle is a type of spaceship. - Sure, those are just slightly different phrases that mean the same thing. Even saying that something is kind of like something else, could be an indicator for inheritance. These help us identify when they're might be some shared attributes between objects, and if we think about it, we can save some time and avoid reinventing the wheel. - Where some people hit their first problem identifying inheritance, is when they start sketching out classes, picking the nouns from the written descriptions. As they scan those objects, they can tell that there's some sort of relationship between cargo and cargo shuttle. But is that an inheritance relationship? This is where the question comes in. Could you say that cargo is a cargo shuttle? - [Man] Well no, and I wouldn't say that a cargo shuttle is cargo either, so there might be some relationship there, cargo shuttles might have cargo, but that's a different relationship than inheritance. Since I could say that a cargo shuttle is a spaceship, and a star fighter is a spaceship, that's a clue that I might be able to share some behavior in that area. If I put those two classes next to each other, it's easy to see that they have several attributes and methods in common. The star fighter and cargo shuttle both have attributes for shield active, shield strength, and position, as well as methods called set shield and move. So I'll strip out those common elements and put them into a super class called spaceship, that star fighter and cargo shuttle sub classes will inherit from. That's indicated in UML diagrams with an open arrow that look like a wedge. The star fighter's method to fire missiles and the cargo shuttle's method to drop cargo remain in their respective sub classes, because those behaviors are unique to each one. From here, we can easily define more types of spaceships, like a warp cruiser, that can automatically inherit all of the elements of the space ship super class. Now there may be times when some of those inherited methods don't quite work for a specific subclass. Maybe our warp cruiser moves differently than a generic spaceship, because after all, it travels at warp speed, and many languages will allow a subclass to replace the implementation of an inherited method through a process called overriding. So the warp cruiser class could override just the move method to use it's own unique version of it. Inheritance can also extend multiple levels deep. If there are going to be other types of vehicles in our game, than we might create a higher level vehicle class for spaceship to inherit from. The is a relationship still holds true here. A warp cruiser is a spaceship, and a spaceship is a vehicle. - Now, a word of warning. It's common for new object orientated developers to overemphasize inheritance. And to come up with class diagrams with five levels of inheritance for everything. Don't go looking for inheritance, because inheritance usually announces itself. If you find yourself creating one or two class diagrams without any inheritance, don't worry. It's perfectly fine.

### Using inheritance

- [Instructor] I want to show you a few examples of how inheritance is implemented across several different languages to help you recognize inheritance when you see it in code. But don't worry about memorizing syntax here, this is just an overview. If I wanted to find a new class called CargoShuttle that inherits from an existing Spaceship class, in Java I would use the keyword extend followed by the name of the class I wanted to inherit from. So CargoShuttle extends Spaceship. In c#, I would use a colon, which is a fairly common way to indicate that CargoShuttle inherits from Spaceship. C++ and Swift both use a similar type of colon notation as well. Now Python is a bit different. Python puts the super class that the new subclass will inherit from in parentheses. And Ruby has its own way of saying that CargoShuttle inherits from Spaceship using the less than symbol. As you can see here, this basic idea of inheritance is really just a minor syntax change between languages. Now when it comes to the details of overriding, that is allowing the subclass to replace the implementation of a method from the superclass. The details are a bit too specific to each language to be useful here. Some languages require keywords, others don't. Some languages require keywords in both the superclass and subclass and so on. For details on overriding, you'll need to refer to your chosen language. That said, when common need is for code within the subclass, the new child class, to call a method that was originally defined in the superclass, its parent, and the word you'll see for that is super. From within one of the methods of our CargoShuttle class, if I want to execute the setShield method that's defined in its superclass Spaceship, using Java I would call super dot and then the method name, so super.setShield. Dot net languages like c# tend to use the word base instead of super because they use the terms base class and derived class rather than superclass and subclass. But the idea behind it is the same. Swift uses the word super, as does Python and Ruby. That's the most common way of doing it. However, c++ is a bit different because c++ allows for multiple inheritance, which means I could be inheriting from multiple classes. So I can't simply say super and know that it will automatically go to the right superclass. In c++ I have to use the official name of whatever superclass I am referring to.

#### Abstract and concrete classes

- We've defined several different types of spaceships for our game. The starfighter, the cargo shuttle - and the warp cruiser. Weeeee. - And all three of those inherit from the same common superclass called spaceship. We'll use those three subclasses to instantiate objects for each specific type of ship but we'll never actually need to instantiate the generic concept of a spaceship. In this case, spaceship can be defined as an abstract class because it exists purely for the sake of being inherited by other classes to provide some shared behavior but an abstract class itself can never be instantiated because it contains at least one abstract method which is a method that's declared with a method signature but not actually implemented in the abstract class. That's deferred to any subclasses that inherit from the abstract class. They're responsible for actually implementing the abstract methods. In uml diagrams we identify spaceship as an abstract class by using italicized font. Now, not every method in an abstract class has to be abstract. The abstract class can have a mix of abstract methods and methods that it actually implements. If all three of our ship types have shields that work the exact same way, rather than making them each implement the same set shield method, we'll implement it once in the spaceship class and they'll all inherit it. But, if each type of ship moves in a different way then each subclass will need to implement its own unique move method. So, we'll declare an abstract move method in our spaceship class. Again, italics are used to indicate that it's abstract and that abstract method serves as a sort of placeholder for each of the subclasses to let them know that they'll need to individually implement it And of course, each of the subclasses are free to implement any additional methods that are unique to them. Some languages like Java or C sharp let you explicitly mark a class as abstract when declaring it which prevents the language from allowing that class to be instantiated. You must inherit from it with another subclass, implement the abstract methods in that subclass and then you can use that subclass to actually instantiate an object. In Java, you can also mark classes as final which has the opposite effect of abstract. A final class is meant to be instantiated and cannot be extended or inherited from. This is often referred to as a concrete class because it implements any missing functionality from the abstract class. Now, not all languages have official keywords to identify abstract and concrete classes and you can treat a class as if it were abstract simply by omission, just don't create an object from it. In fact, we could write our Java code without ever formally marking classes as abstract and it would work just fine. The benefit of including keywords like abstract and final is to communicate your intentions for a class to other programmers. It let's them know whether or not a class was designed with inheritance in mind.

Give feedback
0 notifications total

### Interfaces

- Interfaces are another common form of abstraction that's supported by many object-oriented languages. An interface is a programming structure that declares a set of methods for a class to implement, but the interface itself doesn't contain any functionality. There's no implemented code or behavior. It's just a collection of method signatures to specify a service. For example, in Java an interface would be written like this, using the word interface instead of class. This interface is named Moveable and it declares one method called move. But that method doesn't have a body. Again, you're not allowed to put any functionality inside an interface. When we defined a new class and choose to implement a specific interface, it's like signing a contract, promising that the new class we're defining will implement all of the methods in that interface. But, we're free to implement the inner workings of those methods however we want as long as the method names, inputs, and outputs match the interface. For example, if we define an Asteroid class that implements the Moveable interface, then Asteroid is required to implement the actual code for the move method. - You know, it sounds to me like interfaces are just an extreme version of abstract classes where none of the methods are implemented and everything's abstract. - Interfaces and abstract classes can seem similar at first. But they serve different purposes. Interfaces are used to represent a capability that a class implements. Whereas and abstract class represents a type that another class can inherit from. Consider the abstract Spaceship class that our CargoShuttle class inherits from. It represents a type of object with an is a relationship for inheritance. The CargoShuttle is a Spaceship. Now, let's look at the Asteroid class next to it. Side-by-side it's obvious that Spaceships and Asteroids both have a move method. - [Man] But Asteroids and Spaceships are completely different things. The only thing they have in common is that they both move around in space. - [Woman] Right, it would not make sense for Asteroid to inherit from Spaceship. An Asteroid isn't a type of Spaceship. However, moving is a capability they both share. So they could both implement a common interface for Movable objects. In UML, we represent an interface using a box that looks similar to a class. But we include a tag with double angle quotes to indicate that it's an interface. And, for classes that implement this interface, we use the same arrow as inheritance, but with a dashed line instead of a solid line to indicate that it's implementing an interface rather than inheriting from a class. Now while most languages only allow a class to inherit from one other class, interfaces don't have that restriction. A class can implement multiple interfaces. In our video game, the spaceships and asteroids will both need to be drawn on the screen at some point. In addition to the Movable interface, we can create a second interface that they both implement called Drawable. Now, we don't need to know how the Spaceship and Asteroid's draw method works under the hood. It's just a black box. We just know that for any object, even types of objects that we've never encountered before, as long as it implements the Drawable interface, it will have a draw method that we can call. An example of when this would be useful is if we have a list or collection storing all of the objects in our game. To update the display, we can iterate through each of the potentially unknown objects in that list and simply check if it supports the Drawable interface. So we'll call its draw method to update it on the screen. - That sure is handy. - That's why many developers favor using interfaces to provide a formal list of methods to support. In fact, there's a well known saying that good developers program to an interface not to an implementation because it's a developer's choice how to implement those methods rather than being provided with that code. If your chosen language supports interfaces, then I highly recommend becoming familiar with how they're implemented in that language because interfaces are often a more future friendly way of programming than using inheritance.

Give feedback
0 notifications total

### Aggregation

- Inheritance is just one type of relationship that can exist between objects. The concept of aggregation is another type of object relationship in which one object is built of other objects. - Like this fleet of spaceships. We can think of a fleet as an object that contains a bunch of individual spaceship objects. - [Male Instructor] Aggregation is often referred to as a has a relationship, as opposed to the is a relationship of inheritance. I wouldn't say that the fleet is a spaceship, but I could say that the fleet has a spaceship. - Only one ship? Well, that's a puny little fleet. - Well, in this context, has a can implicitly suggest has many. So a fleet has many spaceships. - That's more like it. - What we're exploring here is that a has a relationship is different from the is a relationship of inheritance. In UML diagrams, we can represent the has a relationship for aggregation with an unfilled diamond. So the diagram here represents a fleet object that contains a collection of spaceship objects. Spaceship refers to an abstract class, so the fleet might contain a variety of different concrete spaceship classes. As with other diagrams, we can optionally indicate multiplicity with an asterisk to say that one fleet can have anywhere from zero to many spaceships. Now, although aggregation is commonly used, it may not always be worth showing on a diagram, because the object lifetimes of those spaceships are not tied to each other or the existence of the fleet. - So what happens when we end the fleet? Do the ships go away? - In the case of aggregation, no. The spaceships each exist independently of the fleet, so destroying the fleet is like breaking up a band. The individual ships can continue to exist and do their own thing. So perhaps a better phrase for an aggregation relationship than has a is uses a, or uses many. The fleet uses many spaceships, and if the fleet ceases to fly together, the individual spaceships will continue to exist on their own.

#### Composition

- A more specific form of aggregation is something called composition. Like aggregation, composition is based around a has-a relationship between objects but it specifically implies ownership. I might say that a spaceship has an engine, but more accurately, I should that the spaceship owns the engine. Composition implies ownership and an engine has no meaning or purpose in the system without a spaceship. - It's like attaching the object to one of these model ships. The spaceship has a shield and, since it's a star fighter, it has a weapon. Or I should say, it owns a weapon. - Right. The space ship is composed of several different objects that each have their own attributes and behaviors. But a key difference between composition and aggregation is that in a composition situation, if the owning object is destroyed by, say, an asteroid ... - Or an Olivia. - The contained objects are destroyed, too. The ships engine, its shield, its weapons, those are all gone. Now, although aggregation may not always be worth showing in a UML diagram, composition often can be and it's represented with a filled-in diamond. If the lifetime of an object is dependent on another object's existence, that's usually worth showing, if for nothing more than to prompt the idea that, when you're defining the owning class, you may need to write constructor and destructor methods to take care of creating and deleting those internal objects. As with aggregation we can use multiplicity symbols to indicate that a spaceship is composed of one or more engines. And we can show other objects that the spaceship has as well, giving it a shield and possibly some weapons, too.

Give feedback
0 notifications total

####cting transcript lines in this section will navigate to timestamp in the video

- Congratulations, you've reached the fifth and final challenge of this course. It builds on the previous four challenges, to create a full class diagram for a spaceship jukebox. For this challenge, you'll be identifying the relationships between classes. If you have your own set of class diagrams from completing the previous challenges, then I encourage you to work from those. Otherwise, feel free to use our class diagrams, shown here. Your goal is to identify opportunities between the classes to implement things like inheritance, interfaces, aggregation, and or composition. And then modify your class diagrams with the appropriate UML markings to indicate those class relationships. To do that correctly, you may need to add or remove some attributes and methods from your existing classes or even create some new classes. That's all part of the challenge. There are a lot of possible solutions here, so take some time to think it through, and when you're done, watch our solution video to see how we approached this problem.

#### OOP support in different languages

- Throughout this course, we've focussed on object-oriented design. The processes and techniques to create a system. And while everything we've covered can be applied to any object-oriented language, it's worthwhile to take a look at some of the differences between the most common ones. One of the main differences between languages is their support for inheritance. Many languages only allow single class inheritance, meaning, a derived class can only inherit from one class. However, C++ and Python support multiple inheritance, where derived class inherits more than one base class, although Ruby doesn't support multiple inheritance, it does have a feature called mixins that allow you to combine objects, though some people see this as more of a form of composition. And finally, JavaScript, which is informal compared to other object-oriented languages. Because it doesn't even use the idea of classes, instead, JavaScript uses prototypes to define its objects, which allows it to be more dynamic. Properties can be dynamically added or removed at runtime. When defining a class hierarchy in a language, the way that calls are made to the super class, base class, or parent class varies. Many languages use a term, super. C++ uses the name of the class, followed by two colons. And since JavaScript doesn't use classes, this doesn't even apply. Most compiled languages are statically typed, meaning, the type of all variables are known at compile time. This means, as a developer, you have to specify the type of every variable you declare. However, scripting languages, like Ruby, Python, and JavaScript, that do not get compiled, are often dynamically typed languages. So, the type of variable doesn't need to be specified. Now, while that can make development faster, and more flexible, it does make it harder to track down bugs if a variables type was misinterpreted at runtime. Because dynamic languages don't require you to specify the type of variables, it also means they don't support interfaces. C++ and Python also don't support the concept of interfaces because they allow for multiple inheritance. However, you could implement something similar using an abstract class and only abstract methods. There are plenty more object-oriented languages than what we've listed here. And there are even special variations that mix or combine some of them together. For example, Jython is a variation of Python that can run on the Java platform, and TypeScript is a variation of JavaScript that allows statically typed variables. You'll notice that different languages often use similar terminology. And they'll have different terms for similar features. Or, they'll use the same term to mean different things. Despite all these differences, all the concepts we've covered in this course apply to any object-oriented language you choose to use.

#### General development principles

- There are always multiple ways to write a piece of code to accomplish the same thing, and programmers love to argue which ways are better. - I know what's best. - However, no matter which solution you choose, there are a few general principles to keep in mind that'll make maintaining your code base easier in the long run. One set of well-known principles has the acronym SOLID, representing five separate, but interrelated principles that apply to any object oriented design, and are intended to make your software more understandable, flexible, and maintainable. For example, the single responsibility principle warns programmers to avoid creating what are called God objects, objects that do a whole lot of things that aren't related to each other. Those behaviors should be split between multiple, smaller classes, that each have one primary responsibility, one reason to exist. If any of your classes start getting too big, always consider if perhaps they should be split into two or more classes that interact with each other. Now, there's a lot more behind these SOLID principles, and they warrant an entire course of their own. So if you want to learn more about them, check out some of the courses on programming principles. Another common principle that forms an acronym, but is much simpler to understand, is Don't Repeat Yourself or DRY. You should avoid copying and pasting large sections of code without any changes because if you realize later that you made a mistake in one of those sections, you'll have to remember all of the places you've copied it and fix those too. That's a maintenance nightmare, and the DRY principle applies to more than just software. We also want to avoid duplication in things like documentation, diagrams, and database schemas. There should only be a single source that can be referenced elsewhere. The last principle I have for you that makes an acronym is YAGNI, which stands for You Ain't Going to Need It. A common trap that many new, overzealous programmers fall into is trying to make their code too extensible, and adding hooks for every possible variation of everything they could ever possibly see. Abstraction is good, and we want to be able to extend our programs, but abstracting too much will mean more testing, more debugging, and code bloat. We don't want to waste time on things that will never be used. Now, there are plenty of tools out there that will plug right into an IDE to do what's called static analysis and highlight some of these things, duplicate code, unnecessary code, or God objects, are examples of some code smells. The code could be valid, it could compile, it could technically work for the problem we're looking to solve, but there's something that just doesn't pass the sniff test. Of course, automated tools won't find everything, and sometimes they'll flag the wrong thing, but many are configurable, and they're a useful tool to help develop a well-designed program. If you want to learn more about code smells, how to recognize them, how to fix them, I recommend checking out some of the other courses on good programming practices.

### Software testing

(keys clicking) - Done, I've created the perfect game, it's ready to be released to our customers. - Did you test it - Kind of, I checked to make sure it meets all the requirements we came up with. - But what happens if a player does something unexpected with the game? Or they use it in a way that wasn't captured in our set of requirements? - Why would they use a perfectly good game wrong? - Perhaps they misunderstood how to play it, or maybe they mistyped something, or maybe they're just mischievous and want to push the boundaries to try and break it. - Well, if they just read the documentation I wrote, they know exactly how to use it. - Documentation, getting starter guides, and training are all good, and can help make a basic user become a power user. The software should be easy and intuitive to use. Imagine we're building an online version of this game, and we ask them to enter their phone number when creating an account. How many digits should we allow the user to enter? - 10 obviously, three for the area code, seven for the rest. - Sure that works if we only have users in North America. But there are plenty of countries where the phone numbers aren't 10 digits, or if they are, it's not necessarily true that the first three are reserved as an area code. Now imagine that you do enter the 10 digits for your phone number, but the application refuses to accept it. It says it's an invalid input, what would you think? - It sounds to me like somebody else wrote a buggy piece of software. - [Olivia] What if I told you that's because the input was expecting dashes to separate the area code from the rest of the number? - How was I supposed to know that? - See, these are some of the usability considerations you've got to keep in mind when creating software. - Shouldn't that have been outlined as part of a use case or something? - Yes, some issues will come up when creating use cases, but we can never anticipate how all our users will choose to use our software. A good thing to always keep in mind is that if there's an optional field, input, or tool, there will always be a user that tries to use it in a way that we were not intending them to. Proper error messages and prompts go a long way to help guide them. - [Male] Testing all of those scenarios sounds pretty tedious. - It sure can be. And no one really wants to spend hours, days, or even weeks, testing the same thing over and over again. That's why creating automated unit tests and system tests as you develop your program is invaluable. Not only will it keep you from doing the same tedious tests over and over again, as things change you can more readily find out if something breaks after that change. - That reminds me of when I've upgraded software before, and suddenly things that had been working fine, stopped working at all. - [Olivia] It's a common complaint when users upgrade software. And it's often caused by developers refactoring between the code releases. Maybe they've discovered a better way to implement a part of the solution, or maybe refactoring was necessary to allow them to add a new feature. Whatever the case may be, refactoring is a natural part of maintaining software over time. - Well shouldn't they have tested it to make sure everything still works the same as before? - They should, and having a well established automated testing system that properly mimics how users interact with the software will help with that. - All right, Olivia, you can get off your soap box. You've convinced me. As exciting as releasing software can be, developing and running a proper test system is just as important as developing he application itself. I guess it's time I check out some other courses on LinkedIn Learning to learn more about software testing.

### Design patterns

- Creating software that merely works is tough enough, but writing code that's also flexible, maintainable, and extensible, that's a real challenge. You should expect your code to undergo multiple changes throughout the development process. And even after being released, most modern applications receive updates to improve features or fix bugs. If you don't structure your code well from the beginning, making those changes can be a major burden. This is where using a design pattern can be really useful. Design patterns are common, repeatable solutions for creating software programs. They define code architectures and best practices for solving common software design problems that occur again and again across all kinds of applications, from business apps to games. Now, design patterns aren't strict standards with exact lines of codes to use, rather they're templates to help structure your code in a smart way. So you'll spend less time refactoring it and more time adding new cool features. Uh-oh, here comes our boss. - Hello Olivia, what's happenin'? That game you and Barron created it's not interesting enough. It needs more types of enemy spaceships to dodge. So um, yeah, I'm going to need you to go ahead and fix that ASAP. Quality assurance is ready to begin testing. (sighing) - Well, it looks like the unnamed programmer who wrote that part of the game hard-coded exactly which ships appear and when. So now I need to track down all the places that occurs to figure out how to add different enemy spaceships that spawn in each level. My life would be a lot easier if we had used a design pattern here, such as the common factory method pattern, which could provide a structured way to instantiate different types of enemy spaceships based on the current level and difficulty setting. But sometimes you inherit bad code, so I'll make those changes. (typing loudly) There, hope I didn't miss a level. - Thanks for makin' those changes, Olivia, but uh, you missed a level. Be more attentive next time. We got feedback from the game testers. They're asking for a time travel feature to let the player rewind the game. So I'm going to need that right away. We're makin' the big game announcement next week. - But that's going to be a lot of work to implement. - Ah yeah, so um, I'm going to need you to go ahead and come in tomorrow, okay. - Ugh, another change. Like everything in programming, there are multiple ways I could build a rewind feature. But for this new feature, it'll be helpful to reference the memento design pattern, which outlines a proven approach for restoring an object to a previous state. Now, I probably won't be able to just copy the memento design pattern straight from a book and have it work here, but the basic structure and concepts behind it will serve as a good starting point to develop my solution. Design patterns became well known from this book, Design Patterns published by a group of authors known as the Gang of Four. Their book details 23 design patterns, which are organized into three groups. Creational patterns, focused on the instantiation of objects and provide clever ways to have more flexibility in how objects are actually created. The structural patterns describe how classes are actually designed. How things like inheritance and composition and aggregation can be used to provide extra functionality. And the behavioral patterns are specifically concerned with the communication between objects as a program is running. In addition to the Gang of Four book, Head First Design Patterns is another great resource that we highly recommend, but if you prefer watching videos over reading books there are plenty of courses available in LinkedIn Learning to learn more about design patterns.

##### Factory Method Patterns

##### Memento Patterns.

Books> Desing Patterns: Elements of Reausable Object-orented Software by
Erich Gamman, Richard Helm, Raph JohnSom, and John Vlissides

Head First Desing patterns.
